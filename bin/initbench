#!/usr/bin/env python3

import argparse
import json
import os
import sys
import time

from typing import NoReturn

sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

from lib.globals import *
from lib.common import (CustomHelpFormatter, view_runtime_config, view_config_file,
                        get_elapsed_time_msg, get_version, print_error)
from lib.funcs_initializer import InitbenchFunctions
from lib.config import ConfigManager
from lib.connection import ConnectionManager
from lib.logger import LoggerManager
from lib.definition import DeclarativeManager


def initializer_cli() -> NoReturn:

    # Working Directory를 ~/cdcbench로 변경
    os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

    parser = argparse.ArgumentParser(prog="initbench", allow_abbrev=False,
                                     add_help=False, argument_default=argparse.SUPPRESS,
                                     formatter_class=CustomHelpFormatter)

    command = parser.add_argument_group(title="Command")
    command_args = ["create", "drop", "reset"]

    command_mxg = command.add_mutually_exclusive_group()
    command_mxg.add_argument("--create", "-c", action="store_true",
                             help="Creates objects and initial data.")

    command_mxg.add_argument("--drop", "-d", action="store_true",
                             help="Drops objects.")

    command_mxg.add_argument("--reset", "-r", action="store_true",
                             help="Re-create objects and initial data.")

    destination_opt = parser.add_argument_group(title="Destination option")

    def check_destination(item: str):
        if item:
            tmp_item: list or str = None
            if item != ",":
                tmp_item = item.strip(",").upper()

            return tmp_item
        else:
            parser.error(f"--destination option value [ {item} ] is invalid syntax")

    destination_opt.add_argument("--destination", "-dest", action="store", nargs="+", metavar="<DB key name>",
                                 type=check_destination,
                                 help="Specifies command destination")

    table_key_opts = parser.add_argument_group(title="Table key options")
    table_key_args = ["primary_key", "unique", "non_key"]

    table_keys_mxg = table_key_opts.add_mutually_exclusive_group()

    table_keys_mxg.add_argument("--primary-key", "-p", action="store_true",
                                help="The key is designated as the primary key when creating the table.")

    table_keys_mxg.add_argument("--unique", "-u", action="store_true",
                                help="The key is designated as the unique key when creating the table.")

    table_keys_mxg.add_argument("--non-key", "-n", action="store_true",
                                help="The key is not generated when the table is created.")

    command_sub_opts = parser.add_argument_group(title="Command Sub-options")
    command_sub_opts_args = ["without_data", "only_data", "assumeyes", "verbose"]

    command_sub_opts_mxg = command_sub_opts.add_mutually_exclusive_group()
    command_sub_opts_mxg.add_argument("--without-data", "-w", action="store_true",
                                      help="Creates only table structures without generate initial data.")

    command_sub_opts_mxg.add_argument("--only-data", "-o", action="store_true",
                                      help="Creates initial data without recreate table structures.")

    command_sub_opts.add_argument("--assumeyes", "-y", action="store_true",
                                  help="Answers yes for question.")

    command_sub_opts.add_argument("--verbose", "-v", action="store_false",
                                  help="Displays the progress of the operation.")

    other_opts = parser.add_argument_group(title="Other options")

    other_opts.add_argument("--config", "-f", action="store", nargs="?", metavar="Configuration File",
                            default=None, help="Displays or specifies configuration file.")

    other_opts.add_argument("--version", "-V", action="version", version=get_version(),
                            help="Displays CDCBENCH version.")

    other_opts.add_argument("--help", "-h", action="help",
                            help="Displays CDCBENCH usage help.")

    args = parser.parse_args()

    # 아무 옵션도 없을 경우 예외처리
    if len(sys.argv) < 2:
        parser.print_help()
        parser.exit(1)

    # Destination option이 Command 없이 사용될 경우 예외처리
    elif hasattr(args, "destination") and not any(hasattr(args, command) for command in command_args):
        parser.error(f"Destination option is required Command")

    # Table key option이 Command 없이 사용될 경우 예외처리
    elif (any(hasattr(args, table_key) for table_key in table_key_args) and
          not any(hasattr(args, command) for command in command_args)):
        parser.error(f"Table key option is required Command")

    # Command Sub option이 Command 없이 사용될 경우 예외처리
    elif (any(hasattr(args, cmd_sub_opt) for cmd_sub_opt in command_sub_opts_args) and
          not any(hasattr(args, command) for command in command_args)):
        parser.error(f"Command Sub-option is required Command")

    # --without-data 옵션이 --create/--reset 옵션없이 사용될 경우 예외처리
    elif hasattr(args, "without_data") and not any(hasattr(args, command) for command in ["create", "reset"]):
        parser.error("--without-data option is required --create/--reset Command")

    # --only-data 옵션이 --create 옵션없이 사용될 경우 예외처리
    elif hasattr(args, "only_data") and not hasattr(args, "create"):
        parser.error("--without-data option is required --create Command")

    # Command parsing 유효성 검사 끝난 후 기본값 세팅
    if not hasattr(args, "verbose"):
        args.verbose = True

    if not any(hasattr(args, table_key) for table_key in table_key_args):
        args.primary_key = True

    try:

        config = ConfigManager(args.config).get_config()

        # --destination option value check 및 값 설정
        if hasattr(args, "destination"):
            db_key_names = set(config.databases.keys())
            set_destination = set(d.upper() for d in args.destination)
            destination_diff_db_key_names = set_destination.difference(db_key_names)
            if "ALL" in args.destination:
                args.destination = list(config.databases.keys())
            elif len(destination_diff_db_key_names) >= 1:
                print_error(f"[ {', '.join(destination_diff_db_key_names)} ] is DB key name that does not exist.")
            else:
                pass
        else:
            args.destination = [list(config.databases.keys())[0]]

        logger = LoggerManager.get_logger(__file__)

        logger.info(f"Module {__file__} is started")

        print(view_runtime_config(config, args))

        # --config 옵션을 제외한 다른 옵션이 없을 경우 해당 Config 내용을 출력 후 종료
        if hasattr(args, "config") and not any(hasattr(args, cmd) for cmd in command_args):
            print(view_config_file(config))
            parser.exit(1)

        # DBMS 미지원 옵션 예외처리
        for d in args.destination:
            if config.databases[d].dbms == MYSQL and hasattr(args, "non_key"):
                print_error("Non-key table is not supported in MySQL, MariaDB")
            elif (config.databases[d].dbms in sa_unsupported_dbms
                  and (hasattr(args, "create") or hasattr(args, "reset"))):
                print_error(f"For {config.databases[d].dbms}, only --without-data option is supported.")

        print(args)
        exit(1)

        # destination별 처리
        if args.target:
            destination_opts = TARGET

            # Connection instance 생성
            logger.debug("Create target connection instance")
            trg_conn = ConnectionManager(config.get_trg_conn_info())

            # Mapper instance 생성
            logger.debug("Create mapper instance")
            trg_mapper = MapperManager(trg_conn).get_mappers()

            # Function instance 생성
            initializer = InitbenchFunctions(trg_conn=trg_conn, trg_mapper=trg_mapper)

            print(view_runtime_config(destination_opts, config.get_config(), args))

        elif args.both:
            destination_opts = BOTH

            # Connection instance 생성
            logger.debug("Create source connection instance")
            src_conn = ConnectionManager(config.get_src_conn_info())
            logger.debug("Create target connection instance")
            trg_conn = ConnectionManager(config.get_trg_conn_info())

            # Mapper instance 생성
            if config.source_dbms_type == config.target_dbms_type:
                src_mapper = MapperManager(src_conn).get_mappers()
                trg_mapper = src_mapper
            else:
                src_mapper = MapperManager(src_conn).get_mappers()
                trg_mapper = MapperManager(trg_conn).get_mappers()

            # Function instance 생성
            initializer = InitbenchFunctions(src_conn=src_conn, src_mapper=src_mapper, trg_conn=trg_conn,
                                             trg_mapper=trg_mapper)

            print(view_runtime_config(destination_opts, config.get_config(), args))

        else:
            destination_opts = SOURCE

            # Connection instance 생성
            logger.debug("Create source connection instance")
            src_conn = ConnectionManager(config.get_src_conn_info())

            # Mapper instance 생성
            logger.debug("Create mapper instance")
            src_mapper = MapperManager(src_conn).get_mappers()

            # Function instance 생성
            initializer = InitbenchFunctions(src_conn=src_conn, src_mapper=src_mapper)

            print(view_runtime_config(destination_opts, config.get_config(), args))

        update_total_data, update_commit_unit, delete_total_data, delete_commit_unit = config.get_init_data_info().values()

        invalid_input_msg = f"{__file__}: warning: invalid input value. please enter \"y\" or \"n\".\n"
        operation_cancel_msg = f"\n{__file__}: warning: operation is canceled by user\n"

        def get_proceed_msg(operation):
            return f"Do you want to {operation} CDCBENCH related objects and data in the above database? [y/N]: "

        def get_selection(print_text):
            """
            사용자에게 안내 메시지를 출력하며, 진행 여부를 입력 받음
            :param print_text: 출력 메시지
            :return: True, False, None
            """
            if args.assumeyes:
                print(print_text)
                user_input = "Y"
            else:
                user_input = input(print_text)

            if len(user_input) == 0 or user_input is None:
                user_input = "N"

            user_input = user_input.strip().upper()

            if user_input == "Y":
                return True
            elif user_input == "N":
                return False
            else:
                return None

        if args.create:
            while True:
                select = get_selection(get_proceed_msg("create"))

                if select is True:
                    print()
                    start_time = time.time()

                    if args.only_data:  # --only-data 옵션일 경우 데이터만 생성함
                        initializer.initializing_data(destination_opts, UPDATE_TEST, update_total_data, update_commit_unit,
                                                      args)
                        initializer.initializing_data(destination_opts, DELETE_TEST, delete_total_data, delete_commit_unit,
                                                      args)

                    else:  # 아닐 경우 Table 생성 절차부터 시작
                        initializer.create(destination_opts, args)

                        if not args.without_data:  # --without-data 옵션이 없을 경우 데이터를 생성함
                            initializer.initializing_data(destination_opts, UPDATE_TEST, update_total_data,
                                                          update_commit_unit, args)
                            initializer.initializing_data(destination_opts, DELETE_TEST, delete_total_data,
                                                          delete_commit_unit, args)

                    end_time = time.time()
                    print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                    break

                elif select is False:
                    print(operation_cancel_msg)
                    break

                else:
                    print(invalid_input_msg)

        elif args.drop:
            while True:
                select = get_selection(get_proceed_msg("drop"))

                if select is True:
                    print()
                    start_time = time.time()

                    initializer.drop(destination_opts, args)

                    end_time = time.time()
                    print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                    break

                elif select is False:
                    print(operation_cancel_msg)
                    break

                else:
                    print(invalid_input_msg)

        elif args.reset:
            while True:
                select = get_selection(get_proceed_msg("reset"))

                if select is True:
                    print()
                    start_time = time.time()

                    initializer.drop(destination_opts, args)
                    initializer.create(destination_opts, args)

                    if not args.without_data:
                        initializer.initializing_data(destination_opts, UPDATE_TEST, update_total_data, update_commit_unit,
                                                      args)
                        initializer.initializing_data(destination_opts, DELETE_TEST, delete_total_data, delete_commit_unit,
                                                      args)

                    end_time = time.time()
                    print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                    break

                elif select is False:
                    print(operation_cancel_msg)
                    break

                else:
                    print(invalid_input_msg)

    except KeyboardInterrupt:
        print(f"\n{__file__}: warning: operation is canceled by user\n")
        exit(1)

    finally:
        print()


if __name__ == "__main__":
    initializer_cli()
