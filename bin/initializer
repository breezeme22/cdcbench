#!/usr/bin/env python3

import os
import argparse
import sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

from commons.constants import *
from commons.funcs_common import get_selection, get_cdcbench_version, get_except_msg, get_true_option, CustomHelpFormatter
from commons.funcs_initializer import FuncsInitializer
from commons.mgr_config import ConfigManager
from commons.mgr_logger import LoggerManager
from commons.mgr_connection import ConnectionManager
from commons.mgr_mappers import set_mappers

from sqlalchemy.exc import DatabaseError, CompileError, InvalidRequestError
from json import JSONDecodeError

# Working Directory를 ~/cdcbench로 변경
os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

# CLI argument parsing
help_formatter = lambda prog: CustomHelpFormatter(prog, max_help_position=18)

parser = argparse.ArgumentParser(prog="initializer", usage="%(prog)s [option...][argument...]", allow_abbrev=False,
                                 formatter_class=help_formatter)

exec_groups = parser.add_mutually_exclusive_group()
dest_groups = parser.add_mutually_exclusive_group()
key_groups = parser.add_mutually_exclusive_group()

exec_groups.add_argument("-c", "--create", action="store_true",
                         help="create the objects and initiate the data.")

exec_groups.add_argument("-d", "--drop", action="store_true",
                         help="drop the objects.")

exec_groups.add_argument("-r", "--reset", action="store_true",
                         help="reset the objects and data.")

dest_groups.add_argument("-s", "--source", action="store_true",
                         help="specify the destination as Source.")

dest_groups.add_argument("-t", "--target", action="store_true",
                         help="specify the destination as Target.")

dest_groups.add_argument("-b", "--both", action="store_true",
                         help="specify the destination as Source and Target.")

key_groups.add_argument("-p", "--primary", action="store_true",
                        help="Set the ID column to Primary Key when creating the table.")

key_groups.add_argument("-u", "--unique", action="store_true",
                        help="Set the ID column to Unique Index when creating the table.")

key_groups.add_argument("-n", "--non-key", action="store_true",
                        help="No constraints are placed on the ID column when creating the table.")

parser.add_argument("-w", "--without-data", action="store_true",
                    help="create only table structures without data.")

parser.add_argument("-f", "--config", action="store", nargs="?", metavar="Configuration File", const="default.ini",
                    help="view or select configuration file.")

parser.add_argument("-v", "--version", action="version", version=get_cdcbench_version(),
                    help="print CDCBENCH\'s Version.")

args = parser.parse_args()

# 아무 옵션도 없을 경우 예외처리
if args.config is None \
        and not args.create and not args.drop and not args.reset \
        and not args.source and not args.target and not args.both\
        and not args.primary and not args.unique and not args.non_key\
        and not args.without_data:
    parser.print_help()
    parser.exit(1)

# --source, --target, --both 옵션만 사용할 경우 예외처리
elif (args.source or args.target or args.both) and (not args.create and not args.drop and not args.reset):
    true_opt = get_true_option(args.__dict__)
    parser.error("--{} option is required --create/--drop/--reset option".format(true_opt))

# --primary, --unique, --non-key 옵션만 사용할 경우 예외처리
elif (args.primary or args.unique or args.non_key) and (not args.create and not args.drop and not args.reset):
    true_opt = get_true_option({"primary": args.primary, "unique": args.unique, "non-key": args.non_key})
    parser.error("--{} option is required --create/--drop/--reset option".format(true_opt))

# --create/--reset 옵션없이 --without-data 옵션을 사용할 경우 예외처리
elif args.without_data and (not args.create and not args.reset):
    parser.error("--without-data option is required --create/--reset option")

config = None
logger = None
sql_logger = None

try:

    if args.config is None:
        config = ConfigManager()
    else:
        config = ConfigManager(args.config)

    # Log Level 설정 및 Logger 획득
    LoggerManager.set_log_level(config.log_level)
    logger = LoggerManager.get_logger(__name__)

    # SQL Log Level 설정 및 Logger 획득
    LoggerManager.set_sql_log_level(config.sql_log_level)
    sql_logger = LoggerManager.get_sql_logger()

    logger.info("Module {} is started".format(__file__))

    # --config 옵션을 제외한 다른 옵션이 없을 경우 해당 Config 내용을 출력 후 종료
    if not args.create and not args.drop and not args.reset \
            and not args.source and not args.target and not args.both \
            and not args.primary and not args.unique and not args.non_key \
            and not args.without_data:
        config.view_config()
        logger.info("Load configuration file ({})".format(config.config_name))
        logger.info(config.get_config_dict())

        parser.exit(1)

    logger.info("Load configuration file ({})".format(config.config_name))
    logger.info(config.get_config_dict())

    # Connection Instance 생성
    conn = ConnectionManager(config)

    # Functions Instance 생성
    funcs = FuncsInitializer(conn, config.source_dbms_type, config.target_dbms_type,
                             config.source_schema_name, config.target_schema_name)

    update_total_data, update_commit_unit, delete_total_data, delete_commit_unit = \
        config.get_init_data_info().values()

    select_warn_msg = "{}: warning: invalid input value. please enter \"y\" or \"n\".\n".format(__file__)

    # destination 옵션 처리
    if args.target:
        destination = TARGET

        # dbms_type이 MySQL일 경우 --non-key/--unique 옵션 예외처리
        if (args.non_key or args.unique) and config.target_dbms_type == MYSQL:
            true_opt = get_true_option({"non-key": args.non_key, "unique": args.unique})
            parser.error("--{} option is not available for that DBMS (MySQL)".format(true_opt))

        print("\n" + config.view_target_connection_config() + "\n\n" +
              config.view_init_data_config() + "\n")
    elif args.both:
        destination = BOTH

        if (args.non_key or args.unique) and (config.source_dbms_type == MYSQL or config.target_dbms_type == MYSQL):
            true_opt = get_true_option({"non-key": args.non_key, "unique": args.unique})
            parser.error("--{} option is not available for that DBMS (MySQL)".format(true_opt))

        print("\n" + config.view_both_connection_config() + "\n\n" +
              config.view_init_data_config() + "\n")
    else:
        destination = SOURCE

        if (args.non_key or args.unique) and config.source_dbms_type == MYSQL:
            true_opt = get_true_option({"non-key": args.non_key, "unique": args.unique})
            parser.error("--{} option is not available for that DBMS (MySQL)".format(true_opt))

        print("\n" + config.view_source_connection_config() + "\n\n" +
              config.view_init_data_config() + "\n")

    # create option
    if args.create:

        print_msg = "Do you want to create CDCBENCH related objects and data from the above database? [y/N]: "

        while True:
            select = get_selection(print_msg)

            if select is True:
                print()
                funcs.create(destination)

                if args.non_key:
                    funcs.drop_primary_keys(destination)
                elif args.unique:
                    funcs.drop_primary_keys(destination)
                    funcs.add_unique_constraints(destination)

                if not args.without_data:
                    funcs.initializing_data(destination, UPDATE_TEST, update_total_data, update_commit_unit)
                    funcs.initializing_data(destination, DELETE_TEST, delete_total_data, delete_commit_unit)
                break
            elif select is False:
                print("\n{}: warning: operation is canceled by user\n".format(__file__))
                break
            else:
                print(select_warn_msg)

    # drop option
    elif args.drop:

        print_msg = "Do you want to drop CDCBENCH related objects and data from the above database? [y/N]: "

        while True:
            select = get_selection(print_msg)

            if select is True:
                print()
                funcs.drop(destination)
                break
            elif select is False:
                print("\n{}: warning: operation is canceled by user\n".format(__file__))
                break

            else:
                print(select_warn_msg)

    # reset option
    elif args.reset:

        print_msg = "Do you want to reset CDCBENCH related objects and data from the above database? [y/N]: "

        while True:
            select = get_selection(print_msg)

            if select is True:
                print()
                funcs.drop(destination)
                funcs.create(destination)

                if args.non_key:
                    funcs.drop_primary_keys(destination)
                elif args.unique:
                    funcs.drop_primary_keys(destination)
                    funcs.add_unique_constraints(destination)

                if not args.without_data:
                    funcs.initializing_data(destination, UPDATE_TEST, update_total_data, update_commit_unit)
                    funcs.initializing_data(destination, DELETE_TEST, delete_total_data, delete_commit_unit)
                break
            elif select is False:
                print("\n{}: warning: operation is canceled by user".format(__file__))
                break
            else:
                print(select_warn_msg)

except FileNotFoundError as ferr:
    get_except_msg(ferr)
    exit(1)

except KeyError as kerr:
    get_except_msg("Configuration parameter does not existed: {}".format(kerr))
    exit(1)

except DatabaseError as dberr:
    get_except_msg(dberr.args[0])
    exit(1)

except CompileError as comperr:
    get_except_msg(comperr.args[0])
    exit(1)

except InvalidRequestError as irerr:
    get_except_msg(irerr.args[0])
    exit(1)

except JSONDecodeError as jerr:
    get_except_msg("Invalid JSON format of data file. line {} column {} (position {})"
                   .format(jerr.lineno, jerr.colno, jerr.pos))

except ValueError as valerr:
    get_except_msg(valerr)
    exit(1)

except KeyboardInterrupt:
    print("\n\n{}: warning: operation is canceled by user  ".format(__file__))
    exit(1)

finally:
    if logger is not None:
        logger.info("Module {} is ended\n".format(__file__))
