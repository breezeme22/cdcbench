#!/usr/bin/env python3

import argparse
import json
import os
import sys
import time
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

from src.constants import *
from src.funcs_common import CustomHelpFormatter, view_runtime_config, view_config_file, \
                             get_elapsed_time_msg, get_cdcbench_version, get_true_option, \
                             exec_database_error
from src.funcs_initializer import FuncsInitializer
from src.mgr_config import ConfigManager
from src.mgr_connection import ConnectionManager
from src.mgr_logger import LoggerManager
from src.mgr_mappers import MapperManager

from sqlalchemy.exc import DatabaseError

# Working Directory를 ~/cdcbench로 변경
os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

parser = argparse.ArgumentParser(prog="initializer", usage="%(prog)s [option...][argument...]", allow_abbrev=False,
                                 formatter_class=lambda prog: CustomHelpFormatter(prog, max_help_position=18))

exec_group = parser.add_mutually_exclusive_group()
destination_group = parser.add_mutually_exclusive_group()
key_group = parser.add_mutually_exclusive_group()

exec_group.add_argument("-c", "--create", action="store_true",
                        help="create the objects and initiate the data.")

exec_group.add_argument("-d", "--drop", action="store_true",
                        help="drop the objects.")

exec_group.add_argument("-r", "--reset", action="store_true",
                        help="reset the objects and data.")

destination_group.add_argument("-s", "--source", action="store_true",
                               help="specify the destination as Source.")

destination_group.add_argument("-t", "--target", action="store_true",
                               help="specify the destination as Target.")

destination_group.add_argument("-b", "--both", action="store_true",
                               help="specify the destination as Source and Target.")

key_group.add_argument("-p", "--primary", action="store_true",
                       help="set the ID column to Primary Key when creating the table.")

key_group.add_argument("-u", "--unique", action="store_true",
                       help="set the ID column to Unique Index when creating the table.")

key_group.add_argument("-n", "--non-key", action="store_true",
                       help="no constraints are placed on the ID column when creating the table.")

parser.add_argument("-w", "--without-data", action="store_true",
                    help="create only table structures without data.")

parser.add_argument("-o", "--only-data", action="store_true",
                    help="create only data without table structures.")

parser.add_argument("-f", "--config", action="store", nargs="?", metavar="Configuration File",
                    const=default_config_name, help="view or select configuration file.")

parser.add_argument("-v", "--verbose", action="store_false",
                    help="display the progress of the operation.")

parser.add_argument("-V", "--version", action="version", version=get_cdcbench_version(),
                    help="print CDCBENCH\'s Version.")

args = parser.parse_args()

# 아무 옵션도 없을 경우 예외처리
if not args.create and not args.drop and not args.reset \
   and not args.source and not args.target and not args.both \
   and not args.primary and not args.unique and not args.non_key \
   and not args.without_data and not args.only_data \
   and args.config is None and args.verbose:
    parser.print_help()
    parser.exit(1)

# Destination/Key Group 옵션이 Exec 옵션없이 사용될 경우 예외처리
elif ((args.source or args.target or args.both) or (args.primary or args.unique or args.non_key)) \
     and (not args.create and not args.drop and not args.reset):
    true_opt = get_true_option({"source": args.source, "target": args.target, "both": args.both,
                                "primary": args.primary, "unique": args.unique, "non-key": args.non_key})
    parser.error("--{} option is required --create/--drop/--reset option".format(true_opt))

# --without-data 옵션이 --create/--reset 옵션없이 사용될 경우 예외처리
elif args.without_data and (not args.create and not args.reset):
    parser.error("--without-data option is required --create/--reset option")

# --only-data 옵션이 --create 옵션없이 사용될 경우 예외처리
elif args.only_data and not args.create:
    parser.error("--only-data option is required --create option")

# --verbose 옵션이 Exec Group 옵션없이 사용될 경우 예외처리
elif not args.verbose and (not args.create and not args.drop and not args.reset):
    parser.error("--verbose option is required --create/--drop/--reset option")

config = None
logger = None
sql_logger = None

try:

    config = ConfigManager(args.config)

    # Log Level 설정 및 Logger 획득
    LoggerManager.set_log_level(config.log_level)
    logger = LoggerManager.get_logger(__file__)

    # SQL Log Level 설정 및 Logger 획득
    LoggerManager.set_sql_log_level(config.sql_log_level)
    sql_logger = LoggerManager.get_sql_logger()

    logger.info(f"Module {__file__} is started")

    # --config 옵션을 제외한 다른 옵션이 없을 경우 해당 Config 내용을 출력 후 종료
    if not args.create and not args.drop and not args.reset \
       and not args.source and not args.target and not args.both \
       and not args.primary and not args.unique and not args.non_key \
       and not args.without_data and not args.only_data and args.verbose:
        print(view_config_file(config.get_config()))
        logger.info(f"Load configuration file ({config.config_name})")
        logger.info(json.dumps(config.get_config(), indent=4))
        parser.exit(1)

    logger.info(f"Load configuration file ({config.config_name})")
    logger.info(json.dumps(config.get_config(), indent=4))

    # dbms_type이 MySQL일 경우 --non-key/--unique 옵션 예외처리
    if (args.non_key or args.unique) and \
       (config.source_dbms_type == MYSQL or config.target_dbms_type == MYSQL):
        true_opt = get_true_option({"non-key": args.non_key, "unique": args.unique})
        parser.error(f"--{true_opt} option is not available for that DBMS (MySQL)")

    # destination별 처리
    if args.target:
        destination = TARGET

        # Connection instance 생성
        logger.debug("Create target connection instance")
        trg_conn = ConnectionManager(config.get_trg_conn_info())

        # Mapper instance 생성
        logger.debug("Create mapper instance")
        trg_mapper = MapperManager(trg_conn).get_mappers()

        # Function instance 생성
        initializer = FuncsInitializer(trg_conn=trg_conn, trg_mapper=trg_mapper)

        print(view_runtime_config(destination, config.get_config(), args))

    elif args.both:
        destination = BOTH

        # Connection instance 생성
        logger.debug("Create source connection instance")
        src_conn = ConnectionManager(config.get_src_conn_info())
        logger.debug("Create target connection instance")
        trg_conn = ConnectionManager(config.get_trg_conn_info())

        # Mapper instance 생성
        if config.source_dbms_type == config.target_dbms_type:
            src_mapper = MapperManager(src_conn).get_mappers()
            trg_mapper = src_mapper
        else:
            src_mapper = MapperManager(src_conn).get_mappers()
            trg_mapper = MapperManager(trg_conn).get_mappers()

        # Function instance 생성
        initializer = FuncsInitializer(src_conn=src_conn, src_mapper=src_mapper, trg_conn=trg_conn, trg_mapper=trg_mapper)

        print(view_runtime_config(destination, config.get_config(), args))

    else:
        destination = SOURCE

        # Connection instance 생성
        logger.debug("Create source connection instance")
        src_conn = ConnectionManager(config.get_src_conn_info())

        # Mapper instance 생성
        logger.debug("Create mapper instance")
        src_mapper = MapperManager(src_conn).get_mappers()

        # Function instance 생성
        initializer = FuncsInitializer(src_conn=src_conn, src_mapper=src_mapper)

        print(view_runtime_config(destination, config.get_config(), args))

    update_total_data, update_commit_unit, delete_total_data, delete_commit_unit = config.get_init_data_info().values()

    invalid_input_msg = f"{__file__}: warning: invalid input value. please enter \"y\" or \"n\".\n"
    operation_cancel_msg = f"\n{__file__}: warning: operation is canceled by user\n"

    # Selection
    def get_selection(print_text):
        user_input = input(print_text)

        if len(user_input) == 0 or user_input is None:
            user_input = "N"

        user_input = user_input.strip().upper()

        if user_input == "Y":
            return True
        elif user_input == "N":
            return False
        else:
            return None

    # create option
    if args.create:
        while True:
            select = get_selection(
                "Do you want to create CDCBENCH related objects and data in the above database? [y/N]: "
            )

            if select is True:
                print()
                start_time = time.time()
                if args.only_data:
                    initializer.initializing_data(destination, UPDATE_TEST, update_total_data, update_commit_unit, args)
                    initializer.initializing_data(destination, DELETE_TEST, delete_total_data, delete_commit_unit, args)
                else:
                    initializer.create(destination, args)

                    if not args.without_data:
                        initializer.initializing_data(destination, UPDATE_TEST, update_total_data, update_commit_unit, args)
                        initializer.initializing_data(destination, DELETE_TEST, delete_total_data, delete_commit_unit, args)

                end_time = time.time()
                print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                break

            elif select is False:
                print(operation_cancel_msg)
                break

            else:
                print(invalid_input_msg)

    # drop option
    elif args.drop:
        while True:
            select = get_selection(
                "Do you want to drop CDCBENCH related objects and data in the above database? [y/N]: "
            )

            if select is True:
                print()
                start_time = time.time()

                initializer.drop(destination, args)

                end_time = time.time()
                print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                break

            elif select is False:
                print(operation_cancel_msg)
                break

            else:
                print(invalid_input_msg)

    # reset option
    elif args.reset:
        while True:
            select = get_selection(
                "Do you want to reset CDCBENCH related objects and data in the above database? [y/N]: "
            )

            if select is True:
                print()
                start_time = time.time()

                initializer.drop(destination, args)
                initializer.create(destination, args)

                if not args.without_data:
                    initializer.initializing_data(destination, UPDATE_TEST, update_total_data, update_commit_unit, args)
                    initializer.initializing_data(destination, DELETE_TEST, delete_total_data, delete_commit_unit, args)

                end_time = time.time()
                print(f"  {get_elapsed_time_msg(end_time, start_time)}")
                break

            elif select is False:
                print(operation_cancel_msg)
                break

            else:
                print(invalid_input_msg)

except DatabaseError as dberr:
    exec_database_error(logger, config.log_level, dberr, fail_print=False)

except KeyboardInterrupt:
    print(f"\n{__file__}: warning: operation is canceled by user\n")
    exit(1)

finally:
    print()
    if logger is not None:
        logger.info(f"Module {__file__} is ended\n")

    if sql_logger is not None:
        sql_logger.info("\n")
