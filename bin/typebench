#!/usr/bin/env python3

from commons.constants import *
from commons.funcs_common import get_true_option, get_cdcbench_version, get_except_msg, CustomHelpFormatter
from commons.funcs_datatype import DataTypeFunctions
from commons.mgr_config import ConfigManager
from commons.mgr_logger import LoggerManager

from sqlalchemy.exc import DatabaseError
from json import JSONDecodeError

import os
import argparse


def typebench():
    # Working Directory를 cdcbench로 변경
    os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

    # CLI argument parsing
    # help_formatter = lambda prog: argparse.RawTextHelpFormatter(prog, max_help_position=6)
    help_formatter = lambda prog: CustomHelpFormatter(prog, max_help_position=18)

    parser = argparse.ArgumentParser(prog="typebench", usage="%(prog)s [option...][argument...]", allow_abbrev=False,
                                     formatter_class=help_formatter)

    type_groups = parser.add_mutually_exclusive_group()
    dml_groups = parser.add_mutually_exclusive_group()

    type_groups.add_argument("-S", "--string", action="store_true",
                             help="specifies table to {}.".format(STRING_TEST))

    type_groups.add_argument("-N", "--numeric", action="store_true",
                             help="specifies table to {}.".format(NUMERIC_TEST))

    type_groups.add_argument("-D", "--datetime", action="store_true",
                             help="specifies table to {}.".format(DATETIME_TEST))

    type_groups.add_argument("-B", "--binary", action="store_true",
                             help="specifies table to {}.".format(BINARY_TEST))

    type_groups.add_argument("-L", "--lob", action="store_true",
                             help="specifies table to {}.".format(LOB_TEST))

    dml_groups.add_argument("-i", "--insert", action="store", metavar="<number of data>", type=int,
                            help="insert data in the specified table.")

    parser.add_argument("-c", "--commit", action="store", metavar="<commit units>", type=int,
                        help="specifies the commit unit. (-i/--insert is required)")

    dml_groups.add_argument("-u", "--update", action="store", nargs=2, metavar=("<start t_id>", "<end t_id>"),
                            type=int, help="update data in the specified table.")

    dml_groups.add_argument("-d", "--delete", action="store", nargs=2, metavar=("<start t_id>", "<end t_id>"),
                            type=int, help="delete data in the specified table.")

    parser.add_argument("-f", "--config", action="store", nargs="?", metavar="file_name", const="default.ini",
                        help="view or select configuration file.")

    parser.add_argument("-v", "--version", action="version", version=get_cdcbench_version(),
                        help="print CDCBENCH\'s version.")

    args = parser.parse_args()

    # --string, --numeric, --date, --binary, --lob 이 --insert, --delete 없이 사용될 때
    if (args.string or args.numeric or args.datetime or args.binary or args.lob) and \
       (not args.insert and not args.update and not args.delete):
        true_opt = get_true_option(args.__dict__)
        parser.error("--{} is required -i/--insert or -u/--update or -d/--delete".format(true_opt))

    # --insert, --delete 가 --string, --numeric, --datetime, --binary, --lob 없이 사용될 때
    elif (not args.string and not args.numeric and not args.datetime and not args.binary and not args.lob) and \
         (args.insert or args.update or args.delete):
        true_opt = get_true_option(args.__dict__)
        parser.error("--{} is required -S/--string or -N/--numeric or -D/--datetime or -B/--binary or -L/--lob".format(true_opt))

    elif args.insert is None and args.commit is not None:
        parser.error("-c/--commit is required -i/--insert")

    config = None
    logger = None
    sql_logger = None

    try:
        # config 옵션 존재 유무에 따라 Config 객체 생성 분리
        # config 옵션 있음
        if args.config:

            config = ConfigManager(args.config)
            logger = LoggerManager.get_logger(__name__, config.log_level)

            logger.info("Module {} is started".format(__file__))

            # -f/--config 옵션을 제외한 다른 옵션이 없을 경우 해당 Config 내용을 출력
            if not args.string and not args.numeric and not args.datetime and not args.binary and not args.lob \
                    and not args.insert and not args.update and not args.delete:
                config.view_config()
                logger.info("Load configuration file ({})".format(config.config_name))
                logger.info(config.get_config_dict())

                exit(1)

        # config 옵션 없음
        elif (args.config is None) and (args.string or args.numeric or args.datetime or args.binary or args.lob or
                                        args.insert or args.update or args.delete):

            config = ConfigManager()
            logger = LoggerManager.get_logger(__name__, config.log_level)

            logger.info("Module {} is started".format(__file__))

        # 아무 옵션도 없을 경우
        else:
            parser.print_help()
            parser.exit(1)

        sql_logger = LoggerManager.get_sql_logger(config.sql_log_level)

        logger.info("Load configuration file ({})".format(config.config_name))
        logger.info(config.get_config_dict())

        datatype_functions = DataTypeFunctions()
        val_err_msg = "value of start t_id is greater than value of end t_id"

        # string execution
        if args.string:

            if args.insert:

                if args.commit:
                    commit_unit = args.commit
                else:
                    commit_unit = 100

                datatype_functions.dtype_insert(STRING_TEST, args.insert, commit_unit)

            elif args.update:

                start_val = args.update[0]
                end_val = args.update[1]

                if start_val <= end_val:
                    datatype_functions.dtype_update(STRING_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

            else:

                start_val = args.delete[0]
                end_val = args.delete[1]

                if start_val <= end_val:
                    datatype_functions.dtype_delete(STRING_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

        # numeric execution
        elif args.numeric:

            if args.insert:

                if args.commit:
                    commit_unit = args.commit
                else:
                    commit_unit = 100

                datatype_functions.dtype_insert(NUMERIC_TEST, args.insert, commit_unit)

            elif args.update:

                start_val = args.update[0]
                end_val = args.update[1]

                if start_val <= end_val:
                    datatype_functions.dtype_update(NUMERIC_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

            else:

                start_val = args.delete[0]
                end_val = args.delete[1]

                if start_val <= end_val:
                    datatype_functions.dtype_delete(NUMERIC_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

        # date execution
        elif args.datetime:

            if args.insert:

                if args.commit:
                    commit_unit = args.commit
                else:
                    commit_unit = 100

                datatype_functions.dtype_insert(DATETIME_TEST, args.insert, commit_unit)

            elif args.update:

                start_val = args.update[0]
                end_val = args.update[1]

                if start_val <= end_val:
                    datatype_functions.dtype_update(DATETIME_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

            else:

                start_val = args.delete[0]
                end_val = args.delete[1]

                if start_val <= end_val:
                    datatype_functions.dtype_delete(DATETIME_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

        # binary execution
        elif args.binary:

            if args.insert:

                if args.commit:
                    commit_unit = args.commit
                else:
                    commit_unit = 100

                datatype_functions.dtype_insert(BINARY_TEST, args.insert, commit_unit)

            elif args.update:

                start_val = args.update[0]
                end_val = args.update[1]

                if start_val <= end_val:
                    datatype_functions.dtype_update(BINARY_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

            else:

                start_val = args.delete[0]
                end_val = args.delete[1]

                if start_val <= end_val:
                    datatype_functions.dtype_delete(BINARY_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

        # lob execution
        elif args.lob:

            if args.insert:

                if args.commit:
                    commit_unit = args.commit
                else:
                    commit_unit = 100

                datatype_functions.dtype_insert(LOB_TEST, args.insert, commit_unit)

            elif args.update:

                start_val = args.update[0]
                end_val = args.update[1]

                if start_val <= end_val:
                    datatype_functions.dtype_update(LOB_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

            else:

                start_val = args.delete[0]
                end_val = args.delete[1]

                if start_val <= end_val:
                    datatype_functions.dtype_delete(LOB_TEST, start_val, end_val)
                else:
                    parser.error(val_err_msg)

    except FileNotFoundError as ferr:
        get_except_msg(ferr)
        exit(1)

    except KeyError as kerr:
        get_except_msg("Configuration Parameter does not existed: {}".format(kerr))
        exit(1)

    except DatabaseError as dberr:
        get_except_msg(dberr.args[0])
        exit(1)

    except JSONDecodeError as jerr:
        get_except_msg("Invalid JSON format of data file. line {} column {} (position {})"
                       .format(jerr.lineno, jerr.colno, jerr.pos))

    except ValueError as valerr:
        get_except_msg(valerr)
        exit(1)

    except UnicodeEncodeError as unierr:
        get_except_msg(unierr)
        print("  * Note. The LOB test file with string must be UTF-8 (without BOM) encoding.\n")
        exit(1)

    finally:
        if logger is not None and sql_logger is not None:
            logger.info("Module {} is ended\n".format(__file__))
            sql_logger.info("\n")


if __name__ == "__main__":
    try:
        typebench()
    except KeyboardInterrupt:
        print("\n{}: warning: operation is canceled by user".format(__file__))
        exit(1)
