#!/usr/bin/env python3

import os
import argparse
import sys
sys.path.append(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

from src.constants import *
from src.funcs_common import get_true_option, get_cdcbench_version, CustomHelpFormatter, view_config_file
from src.funcs_dml import FuncsDml
from src.mgr_config import ConfigManager
from src.mgr_connection import ConnectionManager
from src.mgr_logger import LoggerManager
from src.mgr_mappers import MapperManager

# Working Directory를 cdcbench로 변경
os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), ".."))

parser = argparse.ArgumentParser(prog="cdcbench", usage="%(prog)s [option...][argument...]", allow_abbrev=False,
                                 formatter_class=lambda prog: CustomHelpFormatter(prog, max_help_position=18))

data_category_group = parser.add_mutually_exclusive_group()
dml_group = parser.add_mutually_exclusive_group()

data_category_group.add_argument("-S", "--string", action="store_true",
                                 help="specifies table to {}.".format(STRING_TEST))

data_category_group.add_argument("-N", "--numeric", action="store_true",
                                 help="specifies table to {}.".format(NUMERIC_TEST))

data_category_group.add_argument("-D", "--datetime", action="store_true",
                                 help="specifies table to {}.".format(DATETIME_TEST))

data_category_group.add_argument("-B", "--binary", action="store_true",
                                 help="specifies table to {}.".format(BINARY_TEST))

data_category_group.add_argument("-L", "--lob", action="store_true",
                                 help="specifies table to {}.".format(LOB_TEST))

data_category_group.add_argument("-O", "--oracle", action="store_true",
                                 help="specifies table to {}.".format(ORACLE_TEST))

data_category_group.add_argument("-Q", "--sqlserver", action="store_true",
                                 help="specifies table to {}.".format(SQLSERVER_TEST))

dml_group.add_argument("-i", "--insert", action="store", metavar="<number of data>", type=int,
                       help="insert data in the specified table.")

dml_group.add_argument("-u", "--update", action="store", nargs="*", metavar="ID_value",
                       type=int, help="update data in the specified table.")

dml_group.add_argument("-d", "--delete", action="store", nargs="*", metavar="ID_value",
                       type=int, help="delete data in the specified table.")

parser.add_argument("-c", "--commit", action="store", metavar="<commit units>", type=int,
                    help="specifies the commit unit.")

parser.add_argument("-s", "--single", action="store_true",
                    help="change to single insert. (-i/--insert is required)")

parser.add_argument("-r", "--rollback", action="store_true",
                    help="rollback the entered data.")


def isint(s):
    try:
        int(s)
        return True
    except ValueError:
        return False


parser.add_argument("-C", "--columns", action="store", nargs="+", metavar="column id (or name)",
                    type=lambda item: int(item) if isint(item) else item,
                    help="specifies the column in which want to perform DML "
                         "(cannot use a combination of column_id and column_name)")

parser.add_argument("-w", "--where", action="store",
                    help="specify the update or delete conditions (ex. --update --where \"product_id = 1\")")

parser.add_argument("-sep", "--separate-tx", action="store", metavar="column id (or name)",
                    type=lambda column: int(column) if isint(column) else column,
                    help="separate transactions based on the specified column (--where option required)")

parser.add_argument("-f", "--config", action="store", nargs="?", metavar="Configuration File", const="default.ini",
                    help="view or select configuration file.")

parser.add_argument("-v", "--verbose", action="store_false",
                    help="display the progress of the operation.")

parser.add_argument("-V", "--version", action="version", version=get_cdcbench_version(),
                    help="print CDCBENCH\'s version.")

args = parser.parse_args()

# 아무 옵션도 없을 경우 예외처리
if not args.string and not args.numeric and not args.datetime and not args.binary and not args.lob \
   and not args.oracle and not args.sqlserver \
   and args.insert is None and args.update is None and args.delete is None \
   and args.commit is None and not args.single and not args.rollback and args.columns is None \
   and args.where is None and args.separate_tx is None \
   and args.config is None and args.verbose:
    parser.print_help()
    parser.exit(1)

# --rollback 옵션이 DML Group 옵션없이 사용될 경우 예외처리
elif args.rollback and (args.insert is None and args.update is None and args.delete is None):
    parser.error("--rollback option is required --insert/--update/--delete option")

# --verbose 옵션이 DML Group 옵션없이 사용될 경우 예외처리
elif not args.verbose and (args.insert is None and args.update is None and args.delete is None):
    parser.error("--verbose option is required --insert/--update/--delete option")

# --single 옵션이 --insert 옵션없이 사용될 경우 예외처리
elif args.insert is None and args.single:
    parser.error("--single option is required --insert option")

# --columns 옵션이 --delete 옵션과 함께 사용될 경우 예외처리
elif args.columns is not None and args.delete is not None:
    parser.error("--columns option cannot be used with --delete option")

# --commit 옵션이 --where 옵션과 함께 사용될 경우 예외처리
elif args.commit is not None and args.where is not None:
    parser.error("--commit option cannot be used with --where option")

# --separate-tx 옵션이 --where 옵션없이 사용될 경우 예외처리
elif args.separate_tx is not None and args.where is None:
    parser.error("--separate-tx option is required --where option")

# --columns 옵션에 자료형이 섞여서 저장될 경우 예외처리
if args.columns is not None:
    if all(isinstance(item, int) for item in args.columns):
        pass
    elif all(isinstance(item, str) for item in args.columns):
        pass
    else:
        parser.error("The specified column list is of unsupported format")

val_err_msg = "{} option's second argument is less than first argument"

# --update 옵션 인자 개수별 처리
if args.update is not None:
    if len(args.update) in (0, 1, 2):
        if len(args.update) == 0:
            args.update = "nowhere"
        elif len(args.update) == 1:
            args.update = [args.update[0], args.update[0]]
        elif len(args.update) == 2:
            if args.update[0] <= args.update[1]:
                pass
            else:
                parser.error(val_err_msg.format("--update"))
    else:
        parser.error("--update option's argument is allowed up to two argument")

# --delete 옵션 인자 개수별 처리
if args.delete is not None:
    if len(args.delete) in (0, 1, 2):
        if len(args.delete) == 0:
            args.delete = "nowhere"
        elif len(args.delete) == 1:
            args.delete = [args.delete[0], args.delete[0]]
        elif len(args.delete) == 2:
            if args.delete[0] <= args.delete[1]:
                pass
            else:
                parser.error(val_err_msg.format("--delete"))
    else:
        parser.error("--delete option's argument is allowed up to two argument")

config = None
logger = None
sql_logger = None

try:

    config = ConfigManager(args.config)

    # Log Level 설정 및 Logger 획득
    LoggerManager.set_log_level(config.log_level)
    logger = LoggerManager.get_logger(__file__)
    
    # SQL Log Level 설정 및 Logger 획득
    LoggerManager.set_sql_log_level(config.sql_log_level)
    sql_logger = LoggerManager.get_sql_logger()

    logger.info("Module {} is started".format(__file__))

    # --config 옵션을 제외한 다른 옵션이 없을 경우 해당 Config 내용을 출력
    if not args.string and not args.numeric and not args.datetime and not args.binary and not args.lob \
       and not args.oracle and not args.sqlserver \
       and args.insert is None and args.update is None and args.delete is None \
       and args.commit is None and not args.single and not args.rollback and args.columns is None \
       and args.where is None and args.separate_tx is None \
       and args.verbose:
        print(view_config_file(config.get_config_dict()))
        logger.info("Load configuration file ({})".format(config.config_name))
        logger.info(config.get_config_dict())
        parser.exit(1)

    logger.info("Load configuration file ({})".format(config.config_name))
    logger.info(config.get_config_dict())

    # 각 DBMS별 고유 데이터 타입이 포함된 테이블인 경우 source_dbms_type 값 체크
    if args.oracle is True and (config.source_dbms_type != ORACLE):
        parser.error("Source DBMS is not Oracle.")
    elif args.sqlserver is True and (config.source_dbms_type != SQLSERVER):
        parser.error("Source DBMS is not SQL Server.")

    selected_table = get_true_option({STRING_TEST: args.string, NUMERIC_TEST: args.numeric,
                                      DATETIME_TEST: args.datetime, BINARY_TEST: args.binary, LOB_TEST: args.lob,
                                      ORACLE_TEST: args.oracle, SQLSERVER_TEST: args.sqlserver})

    if selected_table is None:
        selected_table = get_true_option({INSERT_TEST: args.insert, UPDATE_TEST: args.update, DELETE_TEST: args.delete})

    if selected_table == UPDATE_TEST:
        args.columns = ["COL_NAME"]

    conn = ConnectionManager(config.get_src_conn_info())  # Connection Instance 생성

    mapper = MapperManager(conn, selected_table).get_mappers()  # Mapper Instance 생성

    dml = FuncsDml(conn, mapper)  # Functions Instance 생성

    # --commit 옵션 인자 처리
    if args.commit is None:
        args.commit = 1000

    if args.insert:

        if args.single:
            dml.single_insert(selected_table, args.columns, args.insert, args.commit, args.rollback, args.verbose)
        else:
            dml.multi_insert(selected_table, args.columns, args.insert, args.commit, args.rollback, args.verbose)

    elif args.update:

        if args.update == "nowhere" and args.where is None:
            dml.update(selected_table, args.columns, args.where, args.rollback, args.verbose, nowhere=True)
        elif args.separate_tx is not None:
            dml.separated_update(selected_table, args.columns, args.where, args.separate_tx,
                                 args.rollback, args.verbose)
        elif args.where is not None:
            dml.update(selected_table, args.columns, args.where, args.rollback, args.verbose)
        else:
            args.where = f"{args.update[0]} <= T_ID AND T_ID <= {args.update[1]}"
            args.separate_tx = "T_ID"
            dml.separated_update(selected_table, args.columns, args.where, args.separate_tx,
                                 args.rollback, args.verbose, args.commit)

    elif args.delete:

        if args.delete == "nowhere" and args.where is None:
            dml.delete(selected_table, args.where, args.rollback, args.verbose, nowhere=True)
        elif args.separate_tx is not None:
            dml.separated_delete(selected_table, args.where, args.separate_tx, args.rollback, args.verbose)
        elif args.where is not None:
            dml.delete(selected_table, args.where, args.rollback, args.verbose)
        else:
            args.where = f"{args.delete[0]} <= T_ID AND T_ID <= {args.delete[1]}"
            args.separate_tx = "T_ID"
            dml.separated_delete(selected_table, args.where, args.separate_tx, args.rollback, args.verbose, args.commit)

except KeyboardInterrupt:
    print("\n{}: warning: operation is canceled by user".format(__file__))
    exit(1)

finally:
    if logger is not None:
        logger.info("Module {} is ended\n".format(__file__))

    if sql_logger is not None:
        sql_logger.info("\n")
